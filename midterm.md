<div dir="rtl">
<h1>VUE</h1>
<h2>نویسندگان</h2>
<li>مانا عباس‌زاده</li>
<li>محمدمهدی اکبر</li>
<li>دانیال غریب</li>
<hr></hr>
<h2>Vue چیست؟</h2>
Vue js یک framework برای ساختن user interface و همچنین single-page application(SPA) ها می‌باشد.(SPA درواقع به وب اپلیکیشن یا وب سایتی گفته می شود که با کاربر در یک صفحه واحد ارتباط دارد و داینامیک است. و نکته مهم در آن این است که با هر تغییر صفحه حال حاضر را اصطلاحا rewrite می کند به جای اینکه ریکوئست مجدد به سرور بدهد و دوباره صفحه رو لود کند. که این کار و تکنولوژی باعث سریعتر شدن و تجربه بهتری از وبسایت می‌شود)Vue یک فریمورک open-source است و کد مربوط به آن را از 
<a href="https://github.com/vuejs/core">اینجا</a>
می‌توانید ببینید و در آن مشارکت داشته باشید!
<br></br>
<h2>تاریخچه مختصر</h2>
Vue توسط آقای Evan You ساخته شد. که پیش از این برای گوگل کار می‌کرد و از 
<a href="https://angular.io/">Angular</a>
که خود یک فریمورک فرانت دیگر است در تعدادی پروژه استفاده کرده بود.در سال ۲۰۱۳ بر روی Vue کارش را آغاز کرد و در سال ۲۰۱۴ اولین نسخه از این فریمورک را release کرد.
<br></br>
<h2>راه اندازی و آغاز به کار</h2>
<li>پیش نیاز: طبیعتا شما نیاز به یک دانش اولیه و آشنایی با HTML, CSS و JavaScript خواهید داشت چرا که درگیر تگ های مختلف HTML , CSS و کدهای JS خواهید شد.</li>
<br></br>
می توان به ۳ روش زیر با Vue کار کرد:
<h3><li>Online :</h3>
 صرفا برای آشنایی با نحوه کارکرد و دیدکلی اولیه می توان از 
<a href="https://play.vuejs.org/#eNo9jcEKwjAMhl/lt5fpQYfXUQfefAMvvRQbddC1pUuHUPrudg4HIcmXjyRZXEM4zYlEJ+T0iEPgXjn6BB8Zhp46WUZWDjCa9f6w9kAkTtH9CRinV4fmRtZ63H20Ztesqiylphqy3R5UYBqD1UyVAPk+9zkvV1CKbCv9poMLiTEfR2/IXpSoXomqZLtti/IFwVtA9A==">playGround خود Vue</a>
استفاده کرد
</li>
<h3><li>با استفاده از node.js :</h3> برای این روش شما حداقل نیاز به ورژن ۱۶ یا بالاتر از node نیاز دارید.
ابتدا به محلی که می‌خواهید پروژه را ایجاد کنید بروید و کامند زیر را بزنید:
<br>
</li>
</div>
<br>
<div dir="ltr"><code>npm init vue@latest</code></div>
<div dir="rtl"><br>
با اینکار آخرین نسخه vue را دانلود و یک پروژه سمپل برای خود می‌سازید. احتمالا بعد از وارد کردن این کامند تعدادی اپشن به شکل زیر به شما نمایش داده می‌شود که برای شروع می‌توانید حالت پیشفرض هرکدام را بزنید و ادامه دهید.
</div>
<br>

```
✔ Project name: … <your-project-name>
✔ Add TypeScript? … No / Yes
✔ Add JSX Support? … No / Yes
✔ Add Vue Router for Single Page Application development? … No / Yes
✔ Add Pinia for state management? … No / Yes
✔ Add Vitest for Unit testing? … No / Yes
✔ Add an End-to-End Testing Solution? … No / Cypress / Playwright
✔ Add ESLint for code quality? … No / Yes
✔ Add Prettier for code formatting? … No / Yes

Scaffolding project in ./<your-project-name>... Done.
```
<br>
<div dir="rtl">در ادامه وارد پوشه پروژه ای که درمحل زدن کامند ساخته اید بشوید.
وسپس دستورات زیر را بزنید‌:
</div>
<br>
<div>

```
npm install
npm run dev
```
<br>
</div>
<div dir="rtl">
تبریک شما اولین پروژه Vue خود را ساختید. احتمالا در پایان این مرحله درکامند لاین برای شما یک پورت از لوکال هاست نمایش داده می‌شود که پروژه درآنجا بالا آمده. می‌توانید به مرورگر خود بروید و چک کنید.در ادامه هرتغییری که درپروژه می‌دهید نیازمند به ساخته شدن مجدد آن است که می‌توانید با کامند <code>npm run build</code>
آن را مجددا بسازید.</div>
<br>
<div dir = "rtl"> 
<h3><li>با استفاده از CDN </h3>
شما به سادگی می‌توانید در کد html خود تگ اسکریپت مربوط به کدهای ویو را ایمپورت کنید و از آنها استفاده کنید. مانند هرکد js دیگری که برای وب اپلیکیشن خود نوشته اید. برای اینکار باید تگ زیر در کد html شما موجود باشد:
</li></div>
<br>

```html
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
```
<div dir="rtl">
درادامه بیشتر از این مدل از Vue استفاده می‌کنیم و این روش واضح تر می‌شود.
نکته مثبت راجب این مدل استفاده از Vue این است که دیگر نیازی به بیلد کردن نداریم. درادامه به یک سری مفاهیم مهم در Vue می‌پردازیم و Hello World را در Vue پیاده‌سازی ‌می‌کنیم.
<br>
ابتدا یک Hello World ساده و استاتیک را نشان می‌دهیم.صرفا برای آشنایی با سینتکس Vue:<br>
</div>
<div>


    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Vue test</title>
        <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    </head>
    <body>
        <div id="app"></div>
        <script src="app.js"></script>
    </body></div>
<div dir="rtl">ابتدا CDN مربوطه را در اسکریپت نوشته و یک body برای فایل html خود می‌سازیم.
همچنین برای جلوگیری از شلوغی کدهای js را به یک فایل جدای app.js می‌بریم.محتوای فایل app.js نیز به شکل زیر است:</div>

```js
const app = Vue.createApp({
    template: '<h2>Hello World!</h2>'
})

app.mount('#app')
```
<div dir="rtl">همانطور که مشاهده می‌کنید Hello World درصفحه وب شما با اندازه h2 مشاهده می‌شود.
ما یک اپ Vue ساختیم و یک المان template به آن دادیم و دراینجا عینا سینتکس html را نوشته ایم و درنهایت با سینتکس app.mount
به اپی که ساخته ایم میگوییم کجای کد html ما سوار شود.(که دراینجا هرجایی که id ای برابر با app داشته باشد را شامل می‌شود.)</div>
<div dir="rtl">
در Vue دو مفهوم بسیار مهم و اساسی وجود دارد که اصلا دلیل به وجود آمدن آن نیز هست:<br>
<h3>Declarative Rendering</h3>
<h3>Reactivity</h3>
این مفاهیم را سعی می‌کنیم با مثال زیر توضیح دهیم:
<br>

<code>html</code>

```html
   <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    </head>
    <body>
        <h1>hi :)</h1>
        <div id="app">
            <button @click="increase">{{ count }}</button>
        </div>
        <script src="app.js"></script>
    </body>
```

<code>Vue</code>
```js
const app = Vue.createApp({
    data() {
        return {
            count: 0
        }
    },
    methods: {
        increase() {
            this.count++
        }
    }
})
app.mount('#app')
```
می‌توانید این کدرا کپی و امتحان کنید.در اینجا مابرای یک دکمه یک تابع تعریف کردیم (increase) که با هربار کلیک برروی آن متود increase از سمت Vue app کال می‌شود.
و همچنین یک متغیر count داریم که درسمت vue آن را درکد js خود تعریف کرده‌ایم.وبا هربار کلیک برروی دکمه یکی به مقدار آن افزوده می‌شود(مقدار اولیه آن را صفر درنظر گرفتیم)
حال به بررسی مفاهیم گفته شده می‌پردازیم:
<br>
<h3>Declarative Rendering:</h3>
 یک ویژگی مهم و فیچر اصلی در Vue این است که می‌تواند برروی کد html سوار شود و اصطلاحا آن را گسترش(extend) دهد.و DOM باتوجه به کد js ما دیتاهای اضافی ای را می‌گیرد مانند همین count که دراینجا با سینتکس مخصوص {{count}} نشان داده شده است.
<br>
<h3>Reactivity:</h3>
بدین معنی‌ست که تغییرات در JS توسط Vue به طور اتوماتیک همواره شناسایی شده و درکسری از ثانیه برروی DOM اعمال می‌شوند که سرعت بسیار بیشتری نسبت به ریلود کردن یک پیج دارد. مثلن درهمین مثال باهربار کلیک برروی دکمه یکی به عدد روی آن اضافه می‌شود ولی می بینیم که بدون هیچ وقفه ای این عدد در حال اپدیت شدن است. ویژگی Reactivity به ما قدرت مانور بسیاری می‌دهد.
<hr><br>
حال به بررسی یک سری مفاهیم دیگر قبل از آشنایی بیشتر با Vue می‌پردازیم:
<br><br>
<h2>ویو component-based است:</h2>
درواقع کامپوننت های ویو پایه های سازنده یک Vue Application هستندکه به بخشی از کد که ما آن را درون ویو اپلیکیشن گذاشته ایم فانکشنالیتی می‌دهند و خوبی استفاده از آنها این است که UI ای که می‌سازیم را به بخش‌ها و ماژول های کوچکتر تقسیم کنیم تا باسادگی بیشتر با آن کار کنیم و قسمت های مختلف آن را مدیریت کنیم.
همچنین کامپوننت ها می‌توانند به صورت تودرتو باشند! یعنی برای UI های پیچیده تر ما کامپوننت پدر و فرزند داشته باشیم و رابطه بین کامپوننت های داشته باشیم.هر ویو اپلیکیشن از تعدادی کامپوننت تشکیل می‌شود که و هر کامپوننت سه بخش اساسی دارد:
<br>
۱. Template<br>
۲. Script<br>
۳. Styles<br>
دراینجا template بخش مربوط به کنترل کردن html مربوطه است که همانطور که درمثال بالاتر دیده بودیم یک خط کد html را از سمت vue وارد کد کردیم.<br>
بخش Script مربوط به کنترل کردن لاجیک و منطق کلی است و ما می‌توانیم دیتا را در آن تغییر دهیم.<br>
بخش انتهایی نیز استایل های css ای که به کامپوننت لینک شده اند را کنترل می‌کند و با آنها کار می کنیم.<br><br>
<h2>Single-File Component (SFC)</h2>
ما می‌توانیم همه کدبالا که نشان دادیم را در یک فایل تک و تنها پیاده سازی کرده و سپاس آن‌را کامپایل کنیم و نتیجه را مشاهده کنیم.چون این پیاده سازی در یک فایل واحد انجام می‌شود به آن Single-File component گفته می‌شود.یک SFC کل سه مورد بالا که گفته شد (یعنی  Template, Script, Styles) را کپسوله می‌کند و در یک فایل واحد می‌آورد.مثال قبل را می‌توانید در حالت SFC در کد زیر ببینید:

```js
<script>
export default {
  data() {
    return {
      count: 0
    }
  }
}
</script>

<template>
  <button @click="count++">Count is: {{ count }}</button>
</template>

<style scoped>
button {
  font-weight: bold;
}
</style>
```
نکته: اگر از CDN استفاده می‌کنید نمی‌توانید از این روش استفاده کنید چرا که مرحله Build ای درآن وجود ندارد.
<br>
نکته قابل توجه دیگر این است که این مدل پیاده‌سازی منافاتی با seperation of concerns ندارد و دو چیز جدا هستند! عملا ما همه کارها را دریک فایل واحد کرده ایم اما همانطور که می‌بینید بخش های مختلف آن جدا هستند و هر بخش script , template و style کد مخصوص و جدا به خود را دارد.بنابر سلیقه افراد دیزاین های متفاوتی را برای کد Vue خود ممکن است بپسندند!
<br><h2>روش های نوشتن component ها:</h2>
کامپوننت ها در vue می‌تواند به دو شیوه زیر نوشته شوند:
<br>۱. Options-Api : <br>
در این روش ما لاجیک را براساس یک سری شی(Object) به مانند data, methods و  mounted می‌نویسیم و property های داخل این آپشن ها توسط this قابل دسترسی اند که درواقع این this به همان نمونه از کامپوننت اشاره میکند. بالاتر نیز دیدیم برای دسترسی به متغیر count در بخش methods باید از this.count استفاده می‌کردیم وگرنه کد ما متغیر را نمی‌شناخت.
<br>۲. Composition-Api: <br>
در این روش از یک سری تابع های API ایمپورت شده استفاده می‌کنیم تا منطق مورد نظر خود را پیاده کنیم.برای مثال برای کد بالا که با کلیک برروی دکمه مقدار آن زیاد می‌شد معادل Composition-Api آن در زیر آمده است:

```js
<script setup>
import { ref, onMounted } from 'vue'

const count = ref(0)

function increment() {
  count.value++
}

onMounted(() => {
  console.log(`The initial count is ${count.value}.`)
})
</script>

<template>
  <button @click="increment">Count is: {{ count }}</button>
</template>
```

<br>
تگ <code>script setup</code> که در ابتدای کد آمده است معمولا اگر از SFC استفاده می‌کنیم به کار می‌آید که به ویو می‌گوید یک سری عملیات زمان compile-time برای جلوگیری از کندشدن را انجام دهد.
<br><br>
<h3>از کدام یک از شیوه های بالا استفاده باید کرد؟</h3>
هردو روش کارایی لازم برای اکثر کارهای لازم و ضروری که یک برنامه نویس با ویو بخواهد انجام بدهند را دارند. روش options برای کسانی که با زبان های شی گرا آشنایی دارند معمولا راحتتر بنظر می‌رسد چرا که با یکسری Object و روابط آنها کار داریم!اگر نیاز به ساختن یک پروژه کامل دارید بهتر است از composition api استفاده کنید چرا که نیاز به ابزار بیلد کردن خواهید داشت اما اگر از ویو برای کارهای ساده در وب اپلیکیشن خود استفاده می‌کنید بهتر است از ابزارهایی که نیاز به بیلد و کامپایل دارند استفاده نکنید و از روش Options استفاده کنید.درنهایت اما یک انتخاب سلیقه ای محسوب می‌شود.
<br>
<br>
ما در ادامه برای آشنایی با کاربردهای مختلف Vue از روش options-api استفاده میکنیم!<br><br>
نکته : برای جلوگیری از ایمپورت کردن کل ویو هردفعه که باآن کار داریم می‌توانیم تابع یا آبجکت هایی که باآنها کار داریم را صرفا ایمپورت کنیم:
<br>

```js
import { createApp } from 'vue'
```
```js
<script type="importmap">
  {
    "imports": {
      "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
    }
  }
</script>
```
و در کد js خود آدرس CDN را به یک متغیر مانند vue مپ کنیم و درمواقع نیاز تنها چیزی که از آن لازم داریم را ایمپورت کنیم. مانند createApp در بالا.
<hr>
<h2>ساخت Application</h2>
همانطور که دیدیم برای کاربا بخش‌های مختلف DOM نیاز به یک id مشخص داریم که برای آن باید یک اپلیکشن در قسمت vue بسازیم و آن را بر روی آن بخش از کد که آن تگ را دارد mount کنیم. مهم نیست که چه تگی باشد که آن آیدی را دارد ویا یک تگ باشد یا چندین تگ. درنهایت چیزی که mount می‌شود برروی همه آنها تاثیر دارد.
<br>
ما همواره به فانکشن createApp() یک کامپوننت پاس می‌دهیم.درمثال هایی که داشتیم کامپوننت را همانجا می‌ساختیم. اما می‌توان یک کامپوننت ریشه را که ازقبل ساخته شده است نیز پاس داد. این‌کار مخصوصا در وقتی که از SFC استفاده می‌کنیم انجام می‌شود.
<br>

```js
import { createApp } from 'vue'
// import the root component App from a single-file component.
import App from './App.vue'

const app = createApp(App)
```
<br>
توجه کنید که تاوقتی که ما اپلیکیشن را برروی html, mount نکرده ایم هیچ تغییری در صفحه وب ما ایجاد نخواهد شد.
<br>
نکته : گاهی اوقات می‌توان کد بخش template را در همان html نوشت(البته صرفا وقت هایی که عملیات ساده ای را مدنظر داریم)به عنوان مثال در مثال دکمه و افزایش عدد می‌توانیم لاجیک افزایش یافتن را به داخل html ببریم:

```html
<div id="app">
  <button @click="count++">{{ count }}</button>
</div>
```
<br>
یکی دیگر از ویژگی های اینستنس از Application این است که می‌توان یک error-handler دلخواه با توجه به کارایی خودمان برای آن ست کنیم.کافی است از آبجکت .config آن استفاده کنیم.(از .config برای یک سری تنظیمات دیگر اپ نیز می‌توان استفاده کرد که وارد نمی‌شویم):
<br>

```js
app.config.errorHandler = (err) => {
  /* handle error */
}
```
<br>
توجه کنید که ما هرتعداد اپی که بخواهیم می‌توانیم برای یک صفحه html خود بسازیم. درواقع اگر یک صفحه وب داریم و صرفا می‌خواهیم بخش های خاصی از آن را با vue کنترل کنیم بهتر است بجای اینکه کل صفحه را برروی یک اپلیکیشن mount کنیم آنرا به بخش های مجزا تقسیم و هربخش را جداگانه هندل کنیم. این کار readablity و مدیریت صفحه را آسان‌تر خواهد کرد:
<br>

```js
const firstApp = createApp({
  /* ... */
})
app1.mount('#container-1')

const secondApp = createApp({
  /* ... */
})
app2.mount('#container-2')
```
<br>
<hr>
<h2>بعضی از سینتکس‌های مهم Template</h2>
همانطور که پیشتر گفتیم Vue از یک سینتکس برپایه html استفاده می‌کند که دیتای موجود از کامپوننتی که از آن اینستنس گرفته ایم در بخش کد js را متصل و هماهنگ کند با DOM ای که رندر شده است.به این مفهوم مهم اصطلاحا data binding میگوییم و درادامه هرجا از bind و یا binding گفتیم منظورمان همین است.مدل های مختلفی از data binding داریم که بخشی را اینجا مرور می‌کنیم.
<br>
<h3>text interpolation</h3>
ساده ترین نوع binding هست که مثالش را در همان بالاتر دیدیم.
به سینتکس آن سبیل (یا به انگلیسی Mustache) نیز می‌گویند.(به علت شکل آن)
:<br>

```html
<span>Message: {{ msg }}</span>
```
در اینجا همانطور که قبلا نیز داشتیم msg با همان پراپرتی ای که اینستنس خود از Application مربوطه داریم جایگزین می‌شود. و هربار که تغییر کند نیز در صفحه وب ما نیز تغییر خواهد کرد (همان خاصیت reactivity که پیشتر اشاره کردیم)
<h3>html خام</h3>
در حالت قبلی یک تکست را عینا جایگزاری می‌کردیم. اما اگر بخواهیم یک کد html را bind کنیم و نتیجه html آن را ببینیم باید چه کار کنیم؟
در این حالت از دایرکتیو v-html استفاده می‌کنیم.در ادامه بیشتر و مفصل راجب به دستورها (diractives) بحث خواهیم کرد اما در همین حد بدانید که آنهایی که با پیشوند v- شروع می‌شوند غالبا دایرکتیو های ویو هستند.

```html
<p>Using text interpolation: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```
در اینجا درحالت اول عینا کد html را جایگزین کرده اما درحالت دوم و با استفاده از دایرکتیو v-html کد html خروجی اش نمایش داده می‌شود.

```
Using text interpolation: <span style="color: red">This should be red.</span>

Using v-html directive: This should be red.(این بخش درمرورگر خودتان قرمز دیده می‌شود )
```
فقط دقت کنید که شما نمی‌توانید با استفاده از این مدل binding مدل اول را رندر کنید! بعنوان مثال نمی‌توانید یک text interpolation را در دل یک v-html directive بیاورید و انتظار داشته باشید که تکست بین {{}} ها نیز اپدیت و رندر شود. چرا که Vue اساسا یک ماشین بر پایه استرینگ نیست!
<br>
نکته : در استفاده از این مدل binding باید دقت کافی را داشت مخصوصا هنگامی که با دیتایی از سمت کلاینت مواجه هستیم چرا که احتمال حملات 
<a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a>
وجود دارد!
<br>
<h3>Attribute binding</h3>
می‌توان با استفاده از دایرکتیو v-bind اتریبیوت های داخل تگ های html را با دیتاهایی از سمت اینستنس کامپوننتی که داریم هماهنگ کرد.بعنوان مثال:

```html
<div v-bind:id="dynamicId"></div>
```
در اینجا ویو همواره مقدار id را برابر با پراپرتی dynamicId که در سمت کد js می‌باشد هماهنگ می‌کند.البته اگر dynamicId در کد js, null یا undefined باشد آنگاه کل attribute حذف می‌شود.
.چون استفاده از v-bind بسیار زیاد بود سینتکس کوتاه شده زیر را برای آن نیز درنظر گرفته اند:
```html
<div :id="dynamicId"></div>
```
<h3>Boolean Attributes</h3>
فرقی با مورد قبل ندارند صرفا تنها تفاوتشان این است که مقدارشان یا ture است و یا false و html ما برآن اساس رندر می‌شود.

```html
<button :disabled="isButtonDisabled">Button</button>
```
توجه کنید که دراینجا اتریبیوت disabled در صورتی که پراپرتی isButtonDisabled ارزشی برابر با true داشته باشد (می توانید جدول درستی بولین ها درحالات مختلف برای زبان js را از
<a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">
اینجا</a> چک کنید)
و همچنین یک حالت استثنا که اگر برابر با استرینگ خالی یا "" باشد نیز درست است و درغیر این صورت false.
<h3>بایند کردن همزمان چند اتریبیوت</h3>
می‌توان خیلی ساده و بدون تغییر خاصی چند اتریبیوت را همزمان مانند حالت تکی بایند کرد:

اگر بخش دیتای اینستنس ما این شکلی باشد
```js
data() {
  return {
    objectOfAttrs: {
      id: 'container',
      class: 'wrapper'
    }
  }
}
```
می‌توان بدین شکل اتریبیوت ها را بایند کرد:

```html
<div v-bind="objectOfAttrs"></div>
```
<h3>شما می‌توانید از هر عبارتی به زبان js داخل دیتا بایندینگتان استفاده کنید اما باید دقیقا یک عبارت باشد!</h3>
<br>
منظور ازین تیتر این است که ما تاحالا عبارت های ساده داخل دیتا بایندینگ می‌گذاشتیم. اما می‌توانیم از سینتکس های پیچیده‌تر js نیز استفاده کنیم و هر چیزی که یک return value دارد را به عنوان دیتا در بایندینگ مورد نظر بگذاریم.مانند موارد زیر :

```js
{{ number * 10 }}

{{ is_odd ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('-') }}

<div :id="`list-${id}`"></div>
```
دقت کنید که دیتا بایندینگ یک تابع نیز می‌تواند باشه که از بخش methods کامپوننت مربوطه صدا زده شود. چرا که تابع ها نیز یک ریترن ولیو دارند! :

```js
<time :title="toTitleDate(date)" :datetime="date">
  {{ formatDate(date) }}
</time>
```
نکته مهم : چون تابع ها هربار که کامپوننت ما اپدیت می‌شود کال می‌شوند نباید هیچگونه تاثیر برروی فرایند های همزمان دیگر بخش های صفحه وب بگذارند!<br>
همچنین همانطور که گفتیم توجه کنید که فقط وفقط و دقیقا یک اکسپرشن باید در دیتا بایندینگ ما باشد. بعنوان مثال موارد زیر عملی نخواهند بود :

```js
{{ var a = 1 }}

{{ if (ok) { return message } }}
```
عبارت اولی یک statement است و ریترن ولیویی ندارد! و دومی نیز دوتا اکسپرشن به نوعی حساب می‌شود. البته می‌توان آن را در قالب یک عبارت ternary نوشت و به درستی آنگاه کار ‌‌می‌کند!
<br>
نکته‌: تنها یک سری متغیر خاص را بطور پیشفرض می‌توان بایند کرد و برای بقیه تایپ ها اجازه اینکار را نداریم. برای چک کردن اینکه چه جور دیتاتایپ هایی قابل بایند شده اند می‌توانید سری به 
<a href="https://github.com/vuejs/core/blob/main/packages/shared/src/globalsAllowList.ts#L3">این </a>
صفحه گیتهاب از خود Vue Core بزنید!
<h3>Driectives</h3>
در این قسمت مختصر راجب دستورات توضیح می‌دهیم.همانطور که پیشتر دیدیم این دستورات یکجور پیشوند با سینتکس v- هستند مانند v-bind و v-html که پیشتر دیدیم.یک سری دستورات مانند v-for برروی چند عبارت اعمال می‌شوند اما غالبا دایرکتیو ها برروی یک عبارت اعمال می‌شوند.یک دایرکتیو کارش این است که یک ارتباط reactive بین DOM و ولیو هایی که درمقابلش دارد ایجاد کند و باهرتغییری آنها را نیز تغییر دهد.به عنوان مثال برای v-if داریم :

```html
<p v-if="seen">I'm here now!</p>
```
در مثال بالا هرگاه متغیر seen ارزش درستی داشت پاراگراف دیده می‌شود. و هرگاه نادرست بود پاراگراف به طور کلی حذف می‌شود.دقت کنید که حذف شدن با نامرئی شدن دو مقوله جداست!<br>
بعضی اوقات دایرکتیوها می‌توانند آرگومان ورودی داشته باشند. مانند مثال زیر که پیشتر نیز داشتیم :

```html
<a v-on:click="doSomething"> ... </a>

<!-- shorthand -->
<a @click="doSomething"> ... </a>
```

دراینجا click یک آرگومان ورودی برای v-on است که متغیر doSomething را بایند می‌کند با پراپرتی ای که در سمت کد Vue داریم و با توجه به آن DOM را هروقت که نیاز شد آپدیت می‌کند.
<br>
جالب است بدانید Vue آنقدر قدرتمند هست که خود آرگومان ها را نیز بتوانید بایند کنید!برای اینکار باید از [] استفاده کنید. مانند زیر :

```html
<a v-bind:[attributeName]="url"> ... </a>

<!-- shorthand -->
<a :[attributeName]="url"> ... </a>
```
در اینجا attributeName یک متغیر است که بایند می‌شود و مثلا اگر مقدار آن برابر با href شود آنگاه بایندینگ ما مثل یک <code>v-bind:href</code>
خواهد شد!البته دقت کنید چون که آرگومان ها باید نام اتریبیوت های html باشند باید حتما نام و کاراکتر های ولیدی داشته باشند وگرنه ممکن است شما به اخطار کامپایلر برخورد کنید!
مثلا نمی‌توانید از '' یا "" در آرگومان‌ها استفاده کنید.
<br>
ما می‌توانیم از یکسری پسوند خاص به نام modifier ها نیز برای ایجاد رفتار دلخواه خودمان استفاده کنیم. بعنوان مثال اگر نخواهیم یک رویداد (event) درصورتی که توسط برنامه نویس هندل نشد مقدار یا رفتار default خود را انجام ندهد. که اینکار معادل با <code>()event.preventDefault</code>
در کد js است. می‌توان از سینتکس زیر استفاده کرد :

```html
<form @submit.prevent="onSubmit">...</form>
```

در حالت کلی یک دایرکتیو کامل به صورت مقابل است : 
<code>"Name:Argument.Modifier="Value</code>
<br>
<hr>
<h2>نکاتی دررابطه با Reactivity</h2>
همانطور که پیشتر دیدیم برای توصیف اولیه یک متغیر که قرار است در reactivity system قرار بگیرد و باهرتغییر از سمت vue این تغییر در DOM هم اعمال شود ما نیاز داشتیم (البته در دیزاین Option-Api)
که متغیرها و پراپرتی های مورد نظر را در بخش data تعریف کنیم. وسپس در بخش‌های دیگر کامپوننت مانند mounted با this (که به خود اینستنس اشاره می‌کند) قابل دسترسی اند.

```js
export default {
  data() {
    return {
      count: 1
    }
  },
  mounted() {
    // `this` refers to the component instance.
    console.log(this.count) // => 1

    // data can be mutated as well
    this.count = 2
  }
}
```

این پراپرتی ها تنها هنگامی اضافه می‌شوند که اینستنس مربوط به اپ ساخته می‌شود. بنابراین بعدا نمی‌توان یک پراپرتی با قابلیت reactive بودن با استفاده از this.X = a (به عنوان مثال ) ساخت. البته یک متغیر در کامپوننت خواهد شد ولی دیگر خاصیت ریکتیو بودن را ندارد.پس اگر از مقدار یک متغیر در ابتدا مطمئن نیستید می‌توانید در دیتا null یا undefined ریترن کنید.

```js
export default {
  data() {
    return {
      someObject: {}
    }
  },
  mounted() {
    const newObject = {}
    this.someObject = newObject

    console.log(newObject === this.someObject) // false
  }
}
```
نکته : درمثال بالا همانطور که گفتیم someObject خاصیت ریکتیو بودن خود را دارد اما newObject ریکتیو نخواهد بود!
<br>
<h3>متودها</h3>
همانطور که دیدیم می‌توانستیم با استفاده از this دسترسی به پراپرتی مورد نظر خود را در داخل یک تابع که درون اسکوپ :methodes قرار دارد داشته باشیم.توجه داشته باشید که از نوشتن تابع ها به صورت اشاره‌گر خودداری کنید چرا که دیگر دسترسی ای به this نخواهید داشت!

```js
export default {
  methods: {
    increment: () => {
      // BAD: no `this` access here!
    }
  }
}
```
<h3>ویو دارای ریکتیویتی عمیق یا Deep Reactivity است</h3>
منظور چیست؟ یعنی اگر یک ابجکت داشته باشیم که ابجکت ها و یا آرایه های تودرتو داشته باشیم و بخواهیم یکی از فرزندان داخلی را تغییر دهیم همچنان ویو متوجه می‌شود و با توجه به خاصیت ریکتیو بودن DOM را اپدیت می‌کند. به عنوان مثال :

```js
export default {
  data() {
    return {
      obj: {
        nested: { count: 0 },
        arr: ['foo', 'bar']
      }
    }
  },
  methods: {
    mutateDeeply() {
      // these will work as expected.
      this.obj.nested.count++
      this.obj.arr.push('baz')
    }
  }
}
```
<h3>صف آپدیت DOM</h3>
توجه کنید که تغییرات روی کامپوننت ها همه همزمان برروی DOM اعمال نمی‌شوند بلکه یک صفی وجود دارد که ویو آپدیت ها را در آن بافر می کند.برای اینکه آپدیت ها را نگه داریم تا پس از یک تغییر در یک پراپرتی اتفاق بیفتند می‌توان از سینتکس زیر استفاده کرد:

```js
import { nextTick } from 'vue'

export default {
  methods: {
    async increment() {
      this.count++
      await nextTick()
      // Now the DOM is updated
    }
  }
}
```
<hr>
<h2>Computed Properties</h2>
فرض کنید که ما یک سری آبجکت در اپشن دیتای خود داریم :<br>
<br>

```js
export default {
  data() {
    return {
      author: {
        name: 'John Doe',
        books: [
          'Vue 2 - Advanced Guide',
          'Vue 3 - Basic Guide',
          'Vue 4 - The Mystery'
        ]
      }
    }
  }
}
```
حال اگر بخواهیم به صورت شرطی یک سری دیتا را بایند کنیم چه کار میکنیم؟همانطور که پیشتر نیز دیدیم می‌توان کد js را به داخل دیتابایندینگ ها برد : 

```html
<p>Has published books:</p>
<span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>
```

اما همیشه این انتخاب خوبی نیست مخصوصا اگر عبارتی که داخل دیتابایندینگ می‌آید پیچیده شود. آنگاه کد خوانایی و ماندگاری خودش را تا حد خوبی از دست خواهد داد. پس چاره چیست؟
در اینجا computed propery ها به کمک ما می‌آیند : 

```js
export default {
  data() {
    return {
      author: {
        name: 'John Doe',
        books: [
          'Vue 2 - Advanced Guide',
          'Vue 3 - Basic Guide',
          'Vue 4 - The Mystery'
        ]
      }
    }
  },
  computed: {
    // a computed getter
    publishedBooksMessage() {
      // `this` points to the component instance
      return this.author.books.length > 0 ? 'Yes' : 'No'
    }
  }
}
```
ما آنها را در آپشن Computed() می‌گذاریم و داخل آنها مانند متودها یک نوع تابع تعریف می‌کنیم!اما توجه کنید که این تابع نیست و بعدتر توضیح می‌دهیم که فرقی با متود چیست.
سپس می‌توان به سادگی <code>publishedBooksMessage</code>
را بجای لاجیکی که بالاتر به‌کار بردیم درون دیتابایندینگ استفاده کرد :

```html
<p>Has published books:</p>
<span>{{ publishedBooksMessage }}</span>
```
و همچنان خاصیت ریکتیو بودن را حفظ می‌کند.
<br>
اما اگر دقت کنید می‌توانستیم به سادگی از یک متود درون آپشن methods استفاده کنیم. پس چرا نیازی به Computed داشتیم؟

```js
// in component
methods: {
  calculateBooksMessage() {
    return this.author.books.length > 0 ? 'Yes' : 'No'
  }
}
```
تفاوت اینها در ساختار آنهاست. پراپرتی های Computed همواره نگاه به مقادیر ریکتیوی که درون آنهاست و به آنها وابسته اند می‌کنند و به محض تغییر دوباره محاسبه و اپدیت می‌شوند بنابرین اگر DOM دوباره رندر شود ولی ولیو های مورد استفاده از یک Computed تغییری نداشته باشند دیگر دوباره محاسبه و اپدیت نمی‌شود. اما در متود ها اینگونه نیست!هربار که یک نوع re-render در صفحه ما اتفاق می‌افتد آنها دوباره گتر یک تابع را صدا زده و آنرا کال می‌کنند و خروجی را برمی‌گردانند هرچند که یکسان بوده باشد!اما در Computed ها نوعی کش داریم که درصورتی که تغییر نکرده باشند همان مقدار قبلی را سریعا و در کسری از ثانیه برمی‌گردانند. بنابراین Computed پراپرتی ها یک ابزار قدرتمند برای سرعت بخشیدن به وب اپ ما خواهد شد!
توجه کنید که نتیجه از لحاظ منطقی چه با استفاده از Computed و چه با استفاده از method یکسان است اما تفاوت در لود و زمانی است که این دو نتیجه می‌دهند.
<hr>
<h2>بایند کردن استایل ها و کلاس ها</h2>
خیلی وقت‌ها نیاز به تغییر دیزاین و css یک صفحه و یا یک بخش کوچک از یک وب اپ با توجه به شرایط و یا متغیرهای مختلفی در لحظه داریم.می‌توان مانند گذشته از v-bind استفاده کرد اما حواستان باشد که دراین حالت باید استرینگ را به عنوان متغیر پاس بدهیم که پتانسیل بالای برای به خطا خوردن دارد.به این دلیل و هم چون استفاده زیادی از بایند کردن در زمینه css داریم از سینتکس های دیگری نیز برای سهولت استفاده می‌کنیم.به عنوان مثال : 

```html
<div :class="{ myClass: isActive }"></div>
```
در اینجا درصورت درست بودن متغیر <code>isActive</code>
کلس myClass برروی div اعمال می‌شود وگرنه خیر.
می‌توان چندین کلس نیز درکنار هم به این شیوه داشت.همچنین می‌توان جدا از Vue یک کلس دیگر درخود html برای یک div اعمال شود و درنهایت div ما چندین کلس داشته باشد:

<code>vue</code>
```js
data() {
  return {
    isActive: true,
    hasError: false
  }
}
```
<code>html</code>
```html
<div
  class="static"
  :class="{ active: isActive, 'text-danger': hasError }"
></div>
```
در اینجا دردیتا دومتغیر داریم که براساس آن تصمیم می‌گیریم که هنگام بایند شدن چه کلس هایی برای div ما ست شوند. و همچنین یک کلس static جداگانه نیز برای آن در نظر گرفته ایم. در مثال بالا پس از رندر شدن نتیجه زیر برای div حاصل می‌شود (با توجه به ولیو حال حاضر پراپرتی ها)

```html
<div class="static active"></div>
```
و با هرتغییری در مقدار isActive و hasError کلس ما متقابلا آپدیت می‌شود.
همچنین می‌توان لاجیک داخل بایندینگ را مانند گذشته به بخش js برد :
```js
data() {
  return {
    classObject: {
      active: true,
      'text-danger': false
    }
  }
}
```
این کار به خوانایی کد کمک شایانی می‌کند.
```html
<div :class="classObject"></div>
```
همچنین می‌توان با استفاده از یک Computed Property لاجیک های پیچیده تری برای بایندینگ خود درنظر بگیریم. و این یکیاز قدرتمندترین و جذاب‌ترین امکانات ویو برای کار با استایل ها و کلس ها و به طور کلی css است که دست مارا خیلی باز می‌گذارد :

```js
data() {
  return {
    isActive: true,
    error: null
  }
},
computed: {
  classObject() {
    return {
      active: this.isActive && !this.error,
      'text-danger': this.error && this.error.type === 'fatal'
    }
  }
}
```
می‌توان کلس ها را به یک آرایه از کلس ها نیز بایند کرد :<br>

<code>vue</code>
```js
data() {
  return {
    activeClass: 'active',
    errorClass: 'text-danger'
  }
}
```
<code>html</code>
```html
<div :class="[activeClass, errorClass]"></div>
```
پس از رندر شدن ما چند کلس را به اتریبیوت کلس اساین کرده ایم :
```html
<div class="active text-danger"></div>
```
همچنان سینتکس های قبلی برای Array ها نیز صادق‌اند و می‌توان از آنها استفاده کرد :
```html
<div :class="[{ active: isActive }, errorClass]"></div>
```
برای استایل ها نیز به شکل مشابه می‌توان به اتربیوت style درون تگ‌های مختلف html مقادیر دلخواه خود را بایند کنیم. بهطور مثال :

<code>vue</code>

```js
data() {
  return {
    activeColor: 'red',
    fontSize: 30
  }
}
```
<code>html</code>

```css
<div :style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
```
توجه کنید که چون شیوه تایپ معمول در js به طرز cammelCase می‌باشد بهتر است برای best practice متغیر ها را به همین شیوه نام گذاری کنیم. هرچند چون شیوه تایپ مرسوم در css به شیوه kebab-case می‌باشد ویو استثنا این را از ما می‌پذیرد که هنگامی که می‌خواهیم پراپرتی ای را برای تگ استایل بایند کنیم متغیر های خود را به این شیوه نام گذاری کنیم:

```html
<div :style="{ 'font-size': fontSize + 'px' }"></div>
```
مانند قبل نیز می‌توان همه آبجکت ها را در یک آبجکت بزرگتر گذاشت و درنهایت آن آبجکت پدر را بایند کرد. اینکار همواره برای تمیزی و خوانایی کد توصیه می‌شود :

<code>js</code>
```js
data() {
  return {
    styleObject: {
      color: 'red',
      fontSize: '13px'
    }
  }
}
```
<code>html</code>
```html
<div :style="styleObject"></div>
```
مانند کلس ها برای استایل نیز می‌توان آرایه ای از پراپرتی ها به آن داد.
<br>
می‌توان چندین ولیو را در یک آرایه برای یک پراپرتی مختص به یک استایل ست کرد. در این صورت همواره آخرین موردی که مرورگر کلاینت پشتیبانی می کند رندر خواهد شد :

```html
<div :style="{ display: ['-webkit-box', '-ms-flexbox', 'flex'] }"></div>
```
به عنوان مثال اگر مرورگر شما از flex پشتیبانی نکند و از -ms-flexbox پشتیبانی کند چیزی که برای شما رندر خواهد شد <code>display : ms-flexbox</code>
است.
<hr>
<h2>رندر شرطی</h2>
ساده ترین دایرکتیو برای رندر کردن یا نکردن یک بلاک با توجه به یک شرط استفاده از <code>v-if</code>
می‌باشد.

```html
<h1 v-if="isTrue">HELLO</h1>
```
در اینجا اگر isTrue مقدار درست به خود بگیرد این بلاک رندر و در غیر این صورت کلا رندر نخواهد شد.
<br>
اگر بخواهیم درصورت درست نبودن یک شرط یک چیز دیگر را رندر کنیم نیازی به استفاده دوباره از v-if نیست. می توانیم از v-else استفاده کنیم.اما توجه کنید که دایرکتیو v-else باید بلافاصله بعد از v-if و یا v-else-if بیاید.

```html
<h1 v-if="present">HI</h1>
<h1 v-else>BYE</h1>
```
درصورت درست بودن present بلاک اول رندر می‌شود و در غیر این صورت بلاک دوم.<br>
می‌توانیم از یک دایرکتیو دیگر به نام v-else-if استفاده کنیم.
```html
<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>
```
همانطور که می‌بینید در اینجا ویو واقعا شبیه به یک زبان برنامه نویسی سطح بالا عمل می‌کند! 
<br>
اگر بخواهیم شرط v-if درصورت درست بودن چندین بلاک را همزمان رندر کند می‌توانیم همه آنها را در یک تگ <code>template</code>
قرار دهیم :
```html
<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>
```
درصورت رندر شدن خود بلاک template رندر نخواهد شد.
<br>
می‌توان برای رندر شرطی از v-show نیز استفاده کرد اما تفاوت های مهمی با v-if دارد که در ادامه خواهیم گفت.
```html
<h1 v-show="ok">Hello!</h1>
```
دراینجا در صورت درست بودن ok بلاک نمایش داده می‌شود و درغیر این صورت خیر.
تفاوت v-show و v-if در این است که v-show همواره رندر می‌شود. مستقل ازینکه که متغیر روبروی آن درست است و یا خیر.درصورت درست بودن پراپرتی ای که درمقابلش قرار دارد آنگاه آن بلاک در صفحه وب شما نمایش داده می‌شود.به نوعی v-show کاری که می‌کند شبیه پنهان کردن یا نمایش دادن display در css است. اما v-if واقعا یک رندر شرطی را پیاده می‌کند. بدین معنی که درصورت غلط بودن شرط مقابل آن به طور کامل هیچ چیزی از آن بلاک رندر نمی‌شود و اگر قبلا درست بوده باشد آن بلاک به طور کامل پاک شده و جای آن در صفحه مرورگر شما نیز پاک می‌شود.واضح است که v-if هزینه بیشتری برای رندر کردن شما خواهد داشت چرا که ممکن است المان هایی در صفحه شما دراثر درست بودن یا نبودن شرط v-if جابجا شوند!
<hr>
<h2>رندر کردن لیست‌ها</h2>
برای کار با یک لیست از آیتم ها یا آبجکت ها در یک آرایه می‌توانیم از دایرکتیو v-for استفاده کنیم.راه های مختلفی برای ایتریت کردن برروی محتوای آرایه وجود دارد ولی یکی از مرسوم ترین آنها استفاده از سینتکس به شکل  <code>item in items
</code>
است:

<code>vue</code>
```js
data() {
  return {
    jobs: [{ name: 'Doctor' }, { name: 'Firefighter' }]
  }
}
```
<code>html</code>
```html
<li v-for="job in jobs">
  {{ job.name }}
</li>
```
در اینجا کاری که ‌می‌کنیم حالت یک‌نوع forEach زدن در خود js را دارد و بسیار به آن ازین نظر شبیه است.
داخل اسکوپ v-for دسترسی به پراپرتی های دیگر غیر از آرایه نیز داریم.همچنین توجه کنید که مانند forEach زدن اینجا نیز دسترسی به ایندکس آیتمی از آرایه که روی آن ایتریت می‌کنیم وجود دارد:

<code>js</code>
```js
data() {
  return {
    parentMessage: 'Parent',
    items: [{ message: 'Foo' }, { message: 'Bar' }]
  }
}
```
<code>html</code>
```html
<li v-for="(item, index) in items">
  {{ parentMessage }} - {{ index }} - {{ item.message }}
</li>
```
در اینجا هم به ParentMessage و هم به ایندکس های مختلف از آرایه دسترسی داریم.
و خروجی به شکل زیر خواهد بود : 
</div>
<div>
<li>Parent - 0 - Foo
<li>Parent - 1 - Bar
</div>
<div dir="rtl">
همچنین توجه کنید مانند forEach می‌توان به شکل زیر نیز ایتریت کرد :

```html
<li v-for="{ message } in items">
  {{ message }}
</li>

<!-- with index alias -->
<li v-for="({ message }, index) in items">
  {{ message }} {{ index }}
</li>
```
برای حلقه های تودرتو نیز به سادگی دو یا چندبار بسته به نیاز خود از v-for استفاده می‌کنیم. درست مانند یک زبان برنامه نویسی سطح بالا :

```html
<li v-for="item in items">
  <span v-for="childItem in item.children">
    {{ item.message }} {{ childItem }}
  </span>
</li>
```
می‌توان علاوه بر آرایه ها برروی آبجکت ها هم for زد (البته در زبان js آرایه خودش نوعی آبجکت محسوب می‌شود)

<code>js</code>
```js
data() {
  return {
    myObject: {
      title: 'How to do lists in Vue',
      author: 'Jane Doe',
      publishedAt: '2016-04-10'
    }
  }
}
```
<code>html</code>
```html
<ul>
  <li v-for="value in myObject">
    {{ value }}
  </li>
</ul>
```
وقتی روی یک شیء ایتریت می‌کنیم مانند این است که برروی خروجی <code>
()Object.getKeys</code>
داریم for می‌زنیم.
توجه کنید که همانند قبل می‌توان برروی یک tupple از key , value ها از یک آبکجت فور زد :

```html
<li v-for="(value, key) in myObject">
  {{ key }}: {{ value }}
</li>
```
دایرکتیو v-for مي‌تواند برروی یک عدد صحیح نیز حلقه بزند.فقط zero-indexed نیست و از صفر شروع می‌کند.مثلا اگر بخواهیم اعداد ۱ تا ۲۰ را پشت هم بنویسیم می‌توانیم از سینتکس زیر استفاده کنیم :

```html
<span v-for="n in 10">{{ n }}</span>
```
مانند v-if می‌توان v-for را برای یک بلاک template که داخلش چندین بلاک دیگر دارد اعمال کرد :

```html
<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider" role="presentation"></li>
  </template>
</ul>
```
نکته مهم : معمولا استفاده کردن از v-for و v-if به طور همزمان برای یک بلاک یا المنت شما را به دردسر خواهد انداخت! زیرا v-if اولویت بالاتری نسبت به v-for دارد و به اسکوپ متغیر های داخل v-for دسترسی ندارد که این باعث ارور خواهد شد.به مثال زیر توجه کنید :

```html
<li v-for="todo in todos" v-if="!todo.isComplete">
  {{ todo.name }}
</li>
```
در اینجا v-if نمی‌تواند تشخیص بدهد که todo چیست و اصلا برایش در اسکوپ متغیرهای قابل دسترسش تعریف نشده است!برای جلوگیری از این مشکل می‌توان v-for را به یک بلاک پدر template برد :

```html
<template v-for="todo in todos">
  <li v-if="!todo.isComplete">
    {{ todo.name }}
  </li>
</template>
```
در این حالت دیگر اروری نخواهیم داشت.
<br>
وقتی تغییری در لیست به وجود می‌آید طبیعتا با توجه به خاصیت ریکتیو بودن ویو سعی می‌کند که دوباره DOM را آپدیت کند. اما این آپدیت چگونه است؟مثلا اگر ترتیب عناصر یک آرایه بهم ریخته باشد ویو نمی‌آید ترتیب عناصر و یا شاخه های DOM را عوض کند بلکه هر ایندکس از آرایه که به آن می‌رسد را به شکل جداگانه مشخص می‌کند که چه شکلی باید آپدیت شود.برای اینکه به ویو بفهمانیم که برای دوباره رندر کردن می‌تواند از عناصر و المان های پیشین دوباره استفاده کند و صرفا ترتیب آنها را عوض کند می‌توانیم از مفهومی به نام key استفاده کنیم.

```html
<div v-for="item in items" :key="item.id">
  <!-- content -->
</div>
```
هر کلید مخصوص به هر آیتم باید یکتا و مشخص باشد تا ویو بتواند آن را اصطلاحا track کند.این یک best practice هست که هروقت از v-for استفاده می‌کنیم سعی کنیم برای عناصر خود یک آیدی یا کلید و ... مشخص کنیم.
<br>
بعضی وقت‌ها ما نیاز داریم یک ورژن سورت شده یا مثلا وقتی فیلتر خاصی برروی عناصر آرایه انجام می‌شود را نمایش دهیم بدون آنکه خود دیتا را عوض کنیم.در این حالت می‌توانیم مطابق قبلا از Computed استفاده کنیم.مثال زیر را ببینید:

<code>vue</code>

```js
data() {
  return {
    numbers: [1, 2, 3, 4, 5]
  }
},
computed: {
  evenNumbers() {
    return this.numbers.filter(n => n % 2 === 0)
  }
}
```

<code>html</code>

```html
<li v-for="n in evenNumbers">{{ n }}</li>
```
همچنین هنگامی که آرایه های تودرتو و یا آبجکت های تودرتو داریم و نمی‌توانیم از this و computed استفاده کنیم می‌توانیم از متد ها برای نمایش و یا فیلتر خاصی که مدنظر داریم استفاده کنیم :

<code>vue</code>

```js
data() {
  return {
    sets: [[ 1, 2, 3, 4, 5 ], [6, 7, 8, 9, 10]]
  }
},
methods: {
  even(numbers) {
    return numbers.filter(number => number % 2 === 0)
  }
}
```

<code>html</code>

```html
<ul v-for="numbers in sets">
  <li v-for="n in even(numbers)">{{ n }}</li>
</ul>
```
<hr>
<h2>Event Handling</h2>
یکی از مهم ترین سرفصل‌ها و قابلت های ویو همینجاست.ما می‌توانیم برای اتفاقاتی که در DOM می‌افتد یک شنونده بگذاریم که باهربار برانگیخته شدن یک‌سری کد js را صدا و یکسری تابع هارا کال کند و درصورت لزوم تغییرات مورد نیاز در DOM را اجرا و آنرا آپدیت کند.برای شنیدن اتفاقی که در DOM می‌افتد ما از دایرکتیو v-on که مختصرا می‌توان آن را با @ نشان داد استفاده می‌کنیم.
<br>
به دوشکل می‌توان handler را پیاده سازی کرد :
<br>
<li>شیوه Inline</li>
<li>استفاده از Methodها</li>
<h3>Inline Handler</h3>
برای استفاده های مختصر و ساده معمولا استفاده می‌شود.مانند همان مثال دکمه و افزایش عدد count که پیشتر دیدیم :

<code>vue</code>

```js
data() {
  return {
    count: 0
  }
}
```

<code>html</code>

```html
<button @click="count++">Add 1</button>
<p>Count is: {{ count }}</p>
```
همانطور که می‌بینید هندلر در همانجا پیاده سازی شده و دیگر تابع یا متدی از سمت اینستنس را کال نمی‌کند.

<h3>Method Handler</h3>
هنگامی که با منطق پیچیده تری مواجه هستیم و نمی‌توانیم و یا برای جلوگیری از شلوغی نمی‌خواهیم به‌صورت inline منطق ایونت را بنویسیم می‌توانیم از متدها استفاده کنیم و بجای آرگومان v-on یک نام تابع یا محل آن را بنویسیم :

<code>vue</code>

```js
data() {
  return {
    name: 'Vue.js'
  }
},
methods: {
  greet(event) {
    alert(`Hello ${this.name}!`)
    if (event) {
      alert(event.target.tagName)
    }
  }
}
```

<code>html</code>

```html
<button @click="greet">Greet</button>
```
نکته : در این مثال method handler ما به شکل خودکار آبجکت ایونتی از DOM که باعث کال شدن تابع greet می‌شود را به عنوان آرگومان ورودی به تابع می‌دهد و در داخل if با استفاده از <code>event.target.tagName</code>
به اسم این المنت دسترسی خواهیم داشت.(اگر امتحان کنید دوتا alert برای شما خواهد آمد که دومی حاوی کلمه BUTTON است.)
<br>
می‌توان یک متود را به شکل inline نیز کال کرد و به آن آرگومان ورودی داد.مثال :

<code>vue</code>

```js
methods: {
  say(message) {
    alert(message)
  }
}
```

<code>html</code>

```html
<button @click="say('hello')">Say hello</button>
<button @click="say('bye')">Say bye</button>
```
<h3>Event Modifier</h3>
درمواقع زیادی پیش می‌آید که بخواهیم از توابع پیش‌فرض event ها مانند <code>()event.preventDefault</code> یا <code>()event.stopPropagation</code>
استفاده کنیم.همانطور که پیشتر دیدیم می‌توانیم خود event را به عنوان ورودی به متد بدهیم و درآنجا این توابع را کال کنیم.هرچند ویو برای سادگی و راحتی بیشتر یک سری modifier به ما معرفی می‌کند که از همان صفحه html قابل دسترسی اند و همین کار را عینا می‌کنند.

```html
<a @click.stop="doThis"></a>

<form @submit.prevent="onSubmit"></form>

<a @click.stop.prevent="doThat"></a>

<form @submit.prevent></form>

<div @click.self="doThat">...</div>
```
‍‍‍
تواجه کنید که می‌توان از چند مادیفایر برای یک event استفاده کرد اما در عین حال ترتیب استفاده از آنها نیز مهم است.
<br>
می‌توان برای کلیدهای کیبرد نیز مادیفایر مخصوص به آنها را گذاشت تا متوجه شویم فشرده شده اند یا نه که تابع مورد نظر را کال کنیم :

```html
<input @keyup.enter="submit" />
<input @keyup.page-down="onPageDown" />
<input @keyup.alt.enter="clear" />
```

همچنین با استفاده از مادیفایر <code>exact.</code>
می‌توان به ویو فهماند که تنها و تنها درصورتی که ترکیب خاصی از کلید ها فشرده می‌شوند یک تابع یا ایونت را هندل کن:


```html
<!-- this will fire even if Alt or Shift is also pressed -->
<button @click.ctrl="onClick">A</button>

<!-- this will only fire when Ctrl and no other keys are pressed -->
<button @click.ctrl.exact="onCtrlClick">A</button>

<!-- this will only fire when no system modifiers are pressed -->
<button @click.exact="onClick">A</button>
```
برای موس هم مادیفایر های <code>.left .right .middle</cdoe>
قابل استفاده اند.
<hr>

</div>
