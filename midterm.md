<div dir="rtl">
<h1>VUE</h1>
<h2>نویسندگان</h2>
<li>مانا عباس‌زاده</li>
<li>محمدمهدی اکبر</li>
<li>دانیال غریب</li>
<hr></hr>
<h2>Vue چیست؟</h2>
Vue js یک framework برای ساختن user interface و همچنین single-page application(SPA) ها می‌باشد.(SPA درواقع به وب اپلیکیشن یا وب سایتی گفته می شود که با کاربر در یک صفحه واحد ارتباط دارد و داینامیک است. و نکته مهم در آن این است که با هر تغییر صفحه حال حاضر را اصطلاحا rewrite می کند به جای اینکه ریکوئست مجدد به سرور بدهد و دوباره صفحه رو لود کند. که این کار و تکنولوژی باعث سریعتر شدن و تجربه بهتری از وبسایت می‌شود)Vue یک فریمورک open-source است و کد مربوط به آن را از 
<a href="https://github.com/vuejs/core">اینجا</a>
می‌توانید ببینید و در آن مشارکت داشته باشید!
<br></br>
<h2>تاریخچه مختصر</h2>
Vue توسط آقای Evan You ساخته شد. که پیش از این برای گوگل کار می‌کرد و از 
<a href="https://angular.io/">Angular</a>
که خود یک فریمورک فرانت دیگر است در تعدادی پروژه استفاده کرده بود.در سال ۲۰۱۳ بر روی Vue کارش را آغاز کرد و در سال ۲۰۱۴ اولین نسخه از این فریمورک را release کرد.
<br></br>
<h2>راه اندازی و آغاز به کار</h2>
<li>پیش نیاز: طبیعتا شما نیاز به یک دانش اولیه و آشنایی با HTML, CSS و JavaScript خواهید داشت چرا که درگیر تگ های مختلف HTML , CSS و کدهای JS خواهید شد.</li>
<br></br>
می توان به ۳ روش زیر با Vue کار کرد:
<h3><li>Online :</h3>
 صرفا برای آشنایی با نحوه کارکرد و دیدکلی اولیه می توان از 
<a href="https://play.vuejs.org/#eNo9jcEKwjAMhl/lt5fpQYfXUQfefAMvvRQbddC1pUuHUPrudg4HIcmXjyRZXEM4zYlEJ+T0iEPgXjn6BB8Zhp46WUZWDjCa9f6w9kAkTtH9CRinV4fmRtZ63H20Ztesqiylphqy3R5UYBqD1UyVAPk+9zkvV1CKbCv9poMLiTEfR2/IXpSoXomqZLtti/IFwVtA9A==">playGround خود Vue</a>
استفاده کرد
</li>
<h3><li>با استفاده از node.js :</h3> برای این روش شما حداقل نیاز به ورژن ۱۶ یا بالاتر از node نیاز دارید.
ابتدا به محلی که می‌خواهید پروژه را ایجاد کنید بروید و کامند زیر را بزنید:
<br>
</li>
</div>
<br>
<div dir="ltr"><code>npm init vue@latest</code></div>
<div dir="rtl"><br>
با اینکار آخرین نسخه vue را دانلود و یک پروژه سمپل برای خود می‌سازید. احتمالا بعد از وارد کردن این کامند تعدادی اپشن به شکل زیر به شما نمایش داده می‌شود که برای شروع می‌توانید حالت پیشفرض هرکدام را بزنید و ادامه دهید.
</div>
<br>

```
✔ Project name: … <your-project-name>
✔ Add TypeScript? … No / Yes
✔ Add JSX Support? … No / Yes
✔ Add Vue Router for Single Page Application development? … No / Yes
✔ Add Pinia for state management? … No / Yes
✔ Add Vitest for Unit testing? … No / Yes
✔ Add an End-to-End Testing Solution? … No / Cypress / Playwright
✔ Add ESLint for code quality? … No / Yes
✔ Add Prettier for code formatting? … No / Yes

Scaffolding project in ./<your-project-name>... Done.
```
<br>
<div dir="rtl">در ادامه وارد پوشه پروژه ای که درمحل زدن کامند ساخته اید بشوید.
وسپس دستورات زیر را بزنید‌:
</div>
<br>
<div>

```
npm install
npm run dev
```
<br>
</div>
<div dir="rtl">
تبریک شما اولین پروژه Vue خود را ساختید. احتمالا در پایان این مرحله درکامند لاین برای شما یک پورت از لوکال هاست نمایش داده می‌شود که پروژه درآنجا بالا آمده. می‌توانید به مرورگر خود بروید و چک کنید.در ادامه هرتغییری که درپروژه می‌دهید نیازمند به ساخته شدن مجدد آن است که می‌توانید با کامند <code>npm run build</code>
آن را مجددا بسازید.</div>
<br>
<div dir = "rtl"> 
<h3><li>با استفاده از CDN </h3>
شما به سادگی می‌توانید در کد html خود تگ اسکریپت مربوط به کدهای ویو را ایمپورت کنید و از آنها استفاده کنید. مانند هرکد js دیگری که برای وب اپلیکیشن خود نوشته اید. برای اینکار باید تگ زیر در کد html شما موجود باشد:
</li></div>
<br>

```html
<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
```
<div dir="rtl">
درادامه بیشتر از این مدل از Vue استفاده می‌کنیم و این روش واضح تر می‌شود.
نکته مثبت راجب این مدل استفاده از Vue این است که دیگر نیازی به بیلد کردن نداریم. درادامه به یک سری مفاهیم مهم در Vue می‌پردازیم و Hello World را در Vue پیاده‌سازی ‌می‌کنیم.
<br>
ابتدا یک Hello World ساده و استاتیک را نشان می‌دهیم.صرفا برای آشنایی با سینتکس Vue:<br>
</div>
<div>


    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Vue test</title>
        <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    </head>
    <body>
        <div id="app"></div>
        <script src="app.js"></script>
    </body></div>
<div dir="rtl">ابتدا CDN مربوطه را در اسکریپت نوشته و یک body برای فایل html خود می‌سازیم.
همچنین برای جلوگیری از شلوغی کدهای js را به یک فایل جدای app.js می‌بریم.محتوای فایل app.js نیز به شکل زیر است:</div>

```js
const app = Vue.createApp({
    template: '<h2>Hello World!</h2>'
})

app.mount('#app')
```
<div dir="rtl">همانطور که مشاهده می‌کنید Hello World درصفحه وب شما با اندازه h2 مشاهده می‌شود.
ما یک اپ Vue ساختیم و یک المان template به آن دادیم و دراینجا عینا سینتکس html را نوشته ایم و درنهایت با سینتکس app.mount
به اپی که ساخته ایم میگوییم کجای کد html ما سوار شود.(که دراینجا هرجایی که id ای برابر با app داشته باشد را شامل می‌شود.)</div>
<div dir="rtl">
در Vue دو مفهوم بسیار مهم و اساسی وجود دارد که اصلا دلیل به وجود آمدن آن نیز هست:<br>
<h3>Declarative Rendering</h3>
<h3>Reactivity</h3>
این مفاهیم را سعی می‌کنیم با مثال زیر توضیح دهیم:
<br>

<code>html</code>

```html
   <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    </head>
    <body>
        <h1>hi :)</h1>
        <div id="app">
            <button @click="increase">{{ count }}</button>
        </div>
        <script src="app.js"></script>
    </body>
```

<code>Vue</code>
```js
const app = Vue.createApp({
    data() {
        return {
            count: 0
        }
    },
    methods: {
        increase() {
            this.count++
        }
    }
})
app.mount('#app')
```
می‌توانید این کدرا کپی و امتحان کنید.در اینجا مابرای یک دکمه یک تابع تعریف کردیم (increase) که با هربار کلیک برروی آن متود increase از سمت Vue app کال می‌شود.
و همچنین یک متغیر count داریم که درسمت vue آن را درکد js خود تعریف کرده‌ایم.وبا هربار کلیک برروی دکمه یکی به مقدار آن افزوده می‌شود(مقدار اولیه آن را صفر درنظر گرفتیم)
حال به بررسی مفاهیم گفته شده می‌پردازیم:
<br>
<h3>Declarative Rendering:</h3>
 یک ویژگی مهم و فیچر اصلی در Vue این است که می‌تواند برروی کد html سوار شود و اصطلاحا آن را گسترش(extend) دهد.و DOM باتوجه به کد js ما دیتاهای اضافی ای را می‌گیرد مانند همین count که دراینجا با سینتکس مخصوص {{count}} نشان داده شده است.
<br>
<h3>Reactivity:</h3>
بدین معنی‌ست که تغییرات در JS توسط Vue به طور اتوماتیک همواره شناسایی شده و درکسری از ثانیه برروی DOM اعمال می‌شوند که سرعت بسیار بیشتری نسبت به ریلود کردن یک پیج دارد. مثلن درهمین مثال باهربار کلیک برروی دکمه یکی به عدد روی آن اضافه می‌شود ولی می بینیم که بدون هیچ وقفه ای این عدد در حال اپدیت شدن است. ویژگی Reactivity به ما قدرت مانور بسیاری می‌دهد.
<hr><br>
حال به بررسی یک سری مفاهیم دیگر قبل از آشنایی بیشتر با Vue می‌پردازیم:
<br><br>
<h2>ویو component-based است:</h2>
درواقع کامپوننت های ویو پایه های سازنده یک Vue Application هستندکه به بخشی از کد که ما آن را درون ویو اپلیکیشن گذاشته ایم فانکشنالیتی می‌دهند و خوبی استفاده از آنها این است که UI ای که می‌سازیم را به بخش‌ها و ماژول های کوچکتر تقسیم کنیم تا باسادگی بیشتر با آن کار کنیم و قسمت های مختلف آن را مدیریت کنیم.
همچنین کامپوننت ها می‌توانند به صورت تودرتو باشند! یعنی برای UI های پیچیده تر ما کامپوننت پدر و فرزند داشته باشیم و رابطه بین کامپوننت های داشته باشیم.هر ویو اپلیکیشن از تعدادی کامپوننت تشکیل می‌شود که و هر کامپوننت سه بخش اساسی دارد:
<br>
۱. Template<br>
۲. Script<br>
۳. Styles<br>
دراینجا template بخش مربوط به کنترل کردن html مربوطه است که همانطور که درمثال بالاتر دیده بودیم یک خط کد html را از سمت vue وارد کد کردیم.<br>
بخش Script مربوط به کنترل کردن لاجیک و منطق کلی است و ما می‌توانیم دیتا را در آن تغییر دهیم.<br>
بخش انتهایی نیز استایل های css ای که به کامپوننت لینک شده اند را کنترل می‌کند و با آنها کار می کنیم.<br><br>
<h2>Single-File Component (SFC)</h2>
ما می‌توانیم همه کدبالا که نشان دادیم را در یک فایل تک و تنها پیاده سازی کرده و سپاس آن‌را کامپایل کنیم و نتیجه را مشاهده کنیم.چون این پیاده سازی در یک فایل واحد انجام می‌شود به آن Single-File component گفته می‌شود.یک SFC کل سه مورد بالا که گفته شد (یعنی  Template, Script, Styles) را کپسوله می‌کند و در یک فایل واحد می‌آورد.مثال قبل را می‌توانید در حالت SFC در کد زیر ببینید:

```js
<script>
export default {
  data() {
    return {
      count: 0
    }
  }
}
</script>

<template>
  <button @click="count++">Count is: {{ count }}</button>
</template>

<style scoped>
button {
  font-weight: bold;
}
</style>
```
نکته: اگر از CDN استفاده می‌کنید نمی‌توانید از این روش استفاده کنید چرا که مرحله Build ای درآن وجود ندارد.
<br>
نکته قابل توجه دیگر این است که این مدل پیاده‌سازی منافاتی با seperation of concerns ندارد و دو چیز جدا هستند! عملا ما همه کارها را دریک فایل واحد کرده ایم اما همانطور که می‌بینید بخش های مختلف آن جدا هستند و هر بخش script , template و style کد مخصوص و جدا به خود را دارد.بنابر سلیقه افراد دیزاین های متفاوتی را برای کد Vue خود ممکن است بپسندند!
<br><h2>روش های نوشتن component ها:</h2>
کامپوننت ها در vue می‌تواند به دو شیوه زیر نوشته شوند:
<br>۱. Options-Api : <br>
در این روش ما لاجیک را براساس یک سری شی(Object) به مانند data, methods و  mounted می‌نویسیم و property های داخل این آپشن ها توسط this قابل دسترسی اند که درواقع این this به همان نمونه از کامپوننت اشاره میکند. بالاتر نیز دیدیم برای دسترسی به متغیر count در بخش methods باید از this.count استفاده می‌کردیم وگرنه کد ما متغیر را نمی‌شناخت.
<br>۲. Composition-Api: <br>
در این روش از یک سری تابع های API ایمپورت شده استفاده می‌کنیم تا منطق مورد نظر خود را پیاده کنیم.برای مثال برای کد بالا که با کلیک برروی دکمه مقدار آن زیاد می‌شد معادل Composition-Api آن در زیر آمده است:

```js
<script setup>
import { ref, onMounted } from 'vue'

const count = ref(0)

function increment() {
  count.value++
}

onMounted(() => {
  console.log(`The initial count is ${count.value}.`)
})
</script>

<template>
  <button @click="increment">Count is: {{ count }}</button>
</template>
```

<br>
تگ <code>script setup</code> که در ابتدای کد آمده است معمولا اگر از SFC استفاده می‌کنیم به کار می‌آید که به ویو می‌گوید یک سری عملیات زمان compile-time برای جلوگیری از کندشدن را انجام دهد.
<br><br>
<h3>از کدام یک از شیوه های بالا استفاده باید کرد؟</h3>
هردو روش کارایی لازم برای اکثر کارهای لازم و ضروری که یک برنامه نویس با ویو بخواهد انجام بدهند را دارند. روش options برای کسانی که با زبان های شی گرا آشنایی دارند معمولا راحتتر بنظر می‌رسد چرا که با یکسری Object و روابط آنها کار داریم!اگر نیاز به ساختن یک پروژه کامل دارید بهتر است از composition api استفاده کنید چرا که نیاز به ابزار بیلد کردن خواهید داشت اما اگر از ویو برای کارهای ساده در وب اپلیکیشن خود استفاده می‌کنید بهتر است از ابزارهایی که نیاز به بیلد و کامپایل دارند استفاده نکنید و از روش Options استفاده کنید.درنهایت اما یک انتخاب سلیقه ای محسوب می‌شود.
<br>
<br>
ما در ادامه برای آشنایی با کاربردهای مختلف Vue از روش options-api استفاده میکنیم!<br><br>
نکته : برای جلوگیری از ایمپورت کردن کل ویو هردفعه که باآن کار داریم می‌توانیم تابع یا آبجکت هایی که باآنها کار داریم را صرفا ایمپورت کنیم:
<br>

```js
import { createApp } from 'vue'
```
```js
<script type="importmap">
  {
    "imports": {
      "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
    }
  }
</script>
```
و در کد js خود آدرس CDN را به یک متغیر مانند vue مپ کنیم و درمواقع نیاز تنها چیزی که از آن لازم داریم را ایمپورت کنیم. مانند createApp در بالا.
<hr>
<h2>ساخت Application</h2>
همانطور که دیدیم برای کاربا بخش‌های مختلف DOM نیاز به یک id مشخص داریم که برای آن باید یک اپلیکشن در قسمت vue بسازیم و آن را بر روی آن بخش از کد که آن تگ را دارد mount کنیم. مهم نیست که چه تگی باشد که آن آیدی را دارد ویا یک تگ باشد یا چندین تگ. درنهایت چیزی که mount می‌شود برروی همه آنها تاثیر دارد.
<br>
ما همواره به فانکشن createApp() یک کامپوننت پاس می‌دهیم.درمثال هایی که داشتیم کامپوننت را همانجا می‌ساختیم. اما می‌توان یک کامپوننت ریشه را که ازقبل ساخته شده است نیز پاس داد. این‌کار مخصوصا در وقتی که از SFC استفاده می‌کنیم انجام می‌شود.
<br>

```js
import { createApp } from 'vue'
// import the root component App from a single-file component.
import App from './App.vue'

const app = createApp(App)
```
<br>
توجه کنید که تاوقتی که ما اپلیکیشن را برروی html, mount نکرده ایم هیچ تغییری در صفحه وب ما ایجاد نخواهد شد.
<br>
نکته : گاهی اوقات می‌توان کد بخش template را در همان html نوشت(البته صرفا وقت هایی که عملیات ساده ای را مدنظر داریم)به عنوان مثال در مثال دکمه و افزایش عدد می‌توانیم لاجیک افزایش یافتن را به داخل html ببریم:

```html
<div id="app">
  <button @click="count++">{{ count }}</button>
</div>
```
<br>
یکی دیگر از ویژگی های اینستنس از Application این است که می‌توان یک error-handler دلخواه با توجه به کارایی خودمان برای آن ست کنیم.کافی است از آبجکت .config آن استفاده کنیم.(از .config برای یک سری تنظیمات دیگر اپ نیز می‌توان استفاده کرد که وارد نمی‌شویم):
<br>

```js
app.config.errorHandler = (err) => {
  /* handle error */
}
```
<br>
توجه کنید که ما هرتعداد اپی که بخواهیم می‌توانیم برای یک صفحه html خود بسازیم. درواقع اگر یک صفحه وب داریم و صرفا می‌خواهیم بخش های خاصی از آن را با vue کنترل کنیم بهتر است بجای اینکه کل صفحه را برروی یک اپلیکیشن mount کنیم آنرا به بخش های مجزا تقسیم و هربخش را جداگانه هندل کنیم. این کار readablity و مدیریت صفحه را آسان‌تر خواهد کرد:
<br>

```js
const firstApp = createApp({
  /* ... */
})
app1.mount('#container-1')

const secondApp = createApp({
  /* ... */
})
app2.mount('#container-2')
```
<br>
<hr>
<h2>بعضی از سینتکس‌های مهم Template</h2>
همانطور که پیشتر گفتیم Vue از یک سینتکس برپایه html استفاده می‌کند که دیتای موجود از کامپوننتی که از آن اینستنس گرفته ایم در بخش کد js را متصل و هماهنگ کند با DOM ای که رندر شده است.به این مفهوم مهم اصطلاحا data binding میگوییم و درادامه هرجا از bind و یا binding گفتیم منظورمان همین است.مدل های مختلفی از data binding داریم که بخشی را اینجا مرور می‌کنیم.
<br>
<h3>text interpolation</h3>
ساده ترین نوع binding هست که مثالش را در همان بالاتر دیدیم.
به سینتکس آن سبیل (یا به انگلیسی Mustache) نیز می‌گویند.(به علت شکل آن)
:<br>

```html
<span>Message: {{ msg }}</span>
```
در اینجا همانطور که قبلا نیز داشتیم msg با همان پراپرتی ای که اینستنس خود از Application مربوطه داریم جایگزین می‌شود. و هربار که تغییر کند نیز در صفحه وب ما نیز تغییر خواهد کرد (همان خاصیت reactivity که پیشتر اشاره کردیم)
<h3>html خام</h3>
در حالت قبلی یک تکست را عینا جایگزاری می‌کردیم. اما اگر بخواهیم یک کد html را bind کنیم و نتیجه html آن را ببینیم باید چه کار کنیم؟
در این حالت از دایرکتیو v-html استفاده می‌کنیم.در ادامه بیشتر و مفصل راجب به دستورها (diractives) بحث خواهیم کرد اما در همین حد بدانید که آنهایی که با پیشوند v- شروع می‌شوند غالبا دایرکتیو های ویو هستند.

```html
<p>Using text interpolation: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
```
در اینجا درحالت اول عینا کد html را جایگزین کرده اما درحالت دوم و با استفاده از دایرکتیو v-html کد html خروجی اش نمایش داده می‌شود.

```
Using text interpolation: <span style="color: red">This should be red.</span>

Using v-html directive: This should be red.(این بخش درمرورگر خودتان قرمز دیده می‌شود )
```
فقط دقت کنید که شما نمی‌توانید با استفاده از این مدل binding مدل اول را رندر کنید! بعنوان مثال نمی‌توانید یک text interpolation را در دل یک v-html directive بیاورید و انتظار داشته باشید که تکست بین {{}} ها نیز اپدیت و رندر شود. چرا که Vue اساسا یک ماشین بر پایه استرینگ نیست!
<br>
نکته : در استفاده از این مدل binding باید دقت کافی را داشت مخصوصا هنگامی که با دیتایی از سمت کلاینت مواجه هستیم چرا که احتمال حملات 
<a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a>
وجود دارد!
<br>
<h3>Attribute binding</h3>
می‌توان با استفاده از دایرکتیو v-bind اتریبیوت های داخل تگ های html را با دیتاهایی از سمت اینستنس کامپوننتی که داریم هماهنگ کرد.بعنوان مثال:

```html
<div v-bind:id="dynamicId"></div>
```
در اینجا ویو همواره مقدار id را برابر با پراپرتی dynamicId که در سمت کد js می‌باشد هماهنگ می‌کند.البته اگر dynamicId در کد js, null یا undefined باشد آنگاه کل attribute حذف می‌شود.
.چون استفاده از v-bind بسیار زیاد بود سینتکس کوتاه شده زیر را برای آن نیز درنظر گرفته اند:
```html
<div :id="dynamicId"></div>
```
<h3>Boolean Attributes</h3>
فرقی با مورد قبل ندارند صرفا تنها تفاوتشان این است که مقدارشان یا ture است و یا false و html ما برآن اساس رندر می‌شود.

```html
<button :disabled="isButtonDisabled">Button</button>
```
توجه کنید که دراینجا اتریبیوت disabled در صورتی که پراپرتی isButtonDisabled ارزشی برابر با true داشته باشد (می توانید جدول درستی بولین ها درحالات مختلف برای زبان js را از
<a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">
اینجا</a> چک کنید)
و همچنین یک حالت استثنا که اگر برابر با استرینگ خالی یا "" باشد نیز درست است و درغیر این صورت false.
<h3>بایند کردن همزمان چند اتریبیوت</h3>
می‌توان خیلی ساده و بدون تغییر خاصی چند اتریبیوت را همزمان مانند حالت تکی بایند کرد:

اگر بخش دیتای اینستنس ما این شکلی باشد
```js
data() {
  return {
    objectOfAttrs: {
      id: 'container',
      class: 'wrapper'
    }
  }
}
```
می‌توان بدین شکل اتریبیوت ها را بایند کرد:

```html
<div v-bind="objectOfAttrs"></div>
```
<h3>شما می‌توانید از هر عبارتی به زبان js داخل دیتا بایندینگتان استفاده کنید اما باید دقیقا یک عبارت باشد!</h3>
<br>
منظور ازین تیتر این است که ما تاحالا عبارت های ساده داخل دیتا بایندینگ می‌گذاشتیم. اما می‌توانیم از سینتکس های پیچیده‌تر js نیز استفاده کنیم و هر چیزی که یک return value دارد را به عنوان دیتا در بایندینگ مورد نظر بگذاریم.مانند موارد زیر :

```js
{{ number * 10 }}

{{ is_odd ? 'YES' : 'NO' }}

{{ message.split('').reverse().join('-') }}

<div :id="`list-${id}`"></div>
```
دقت کنید که دیتا بایندینگ یک تابع نیز می‌تواند باشه که از بخش methods کامپوننت مربوطه صدا زده شود. چرا که تابع ها نیز یک ریترن ولیو دارند! :

```js
<time :title="toTitleDate(date)" :datetime="date">
  {{ formatDate(date) }}
</time>
```
نکته مهم : چون تابع ها هربار که کامپوننت ما اپدیت می‌شود کال می‌شوند نباید هیچگونه تاثیر برروی فرایند های همزمان دیگر بخش های صفحه وب بگذارند!<br>
همچنین همانطور که گفتیم توجه کنید که فقط وفقط و دقیقا یک اکسپرشن باید در دیتا بایندینگ ما باشد. بعنوان مثال موارد زیر عملی نخواهند بود :

```js
{{ var a = 1 }}

{{ if (ok) { return message } }}
```
عبارت اولی یک statement است و ریترن ولیویی ندارد! و دومی نیز دوتا اکسپرشن به نوعی حساب می‌شود. البته می‌توان آن را در قالب یک عبارت ternary نوشت و به درستی آنگاه کار ‌‌می‌کند!
<br>
نکته‌: تنها یک سری متغیر خاص را بطور پیشفرض می‌توان بایند کرد و برای بقیه تایپ ها اجازه اینکار را نداریم. برای چک کردن اینکه چه جور دیتاتایپ هایی قابل بایند شده اند می‌توانید سری به 
<a href="https://github.com/vuejs/core/blob/main/packages/shared/src/globalsAllowList.ts#L3">این </a>
صفحه گیتهاب از خود Vue Core بزنید!
<h3>Driectives</h3>
در این قسمت مختصر راجب دستورات توضیح می‌دهیم.همانطور که پیشتر دیدیم این دستورات یکجور پیشوند با سینتکس v- هستند مانند v-bind و v-html که پیشتر دیدیم.یک سری دستورات مانند v-for برروی چند عبارت اعمال می‌شوند اما غالبا دایرکتیو ها برروی یک عبارت اعمال می‌شوند.یک دایرکتیو کارش این است که یک ارتباط reactive بین DOM و ولیو هایی که درمقابلش دارد ایجاد کند و باهرتغییری آنها را نیز تغییر دهد.به عنوان مثال برای v-if داریم :

```html
<p v-if="seen">I'm here now!</p>
```
در مثال بالا هرگاه متغیر seen ارزش درستی داشت پاراگراف دیده می‌شود. و هرگاه نادرست بود پاراگراف به طور کلی حذف می‌شود.دقت کنید که حذف شدن با نامرئی شدن دو مقوله جداست!<br>
بعضی اوقات دایرکتیوها می‌توانند آرگومان ورودی داشته باشند. مانند مثال زیر که پیشتر نیز داشتیم :

```html
<a v-on:click="doSomething"> ... </a>

<!-- shorthand -->
<a @click="doSomething"> ... </a>
```

دراینجا click یک آرگومان ورودی برای v-on است که متغیر doSomething را بایند می‌کند با پراپرتی ای که در سمت کد Vue داریم و با توجه به آن DOM را هروقت که نیاز شد آپدیت می‌کند.
<br>
جالب است بدانید Vue آنقدر قدرتمند هست که خود آرگومان ها را نیز بتوانید بایند کنید!برای اینکار باید از [] استفاده کنید. مانند زیر :

```html
<a v-bind:[attributeName]="url"> ... </a>

<!-- shorthand -->
<a :[attributeName]="url"> ... </a>
```
در اینجا attributeName یک متغیر است که بایند می‌شود و مثلا اگر مقدار آن برابر با href شود آنگاه بایندینگ ما مثل یک <code>v-bind:href</code>
خواهد شد!البته دقت کنید چون که آرگومان ها باید نام اتریبیوت های html باشند باید حتما نام و کاراکتر های ولیدی داشته باشند وگرنه ممکن است شما به اخطار کامپایلر برخورد کنید!
مثلا نمی‌توانید از '' یا "" در آرگومان‌ها استفاده کنید.
<br>
ما می‌توانیم از یکسری پسوند خاص به نام modifier ها نیز برای ایجاد رفتار دلخواه خودمان استفاده کنیم. بعنوان مثال اگر نخواهیم یک رویداد (event) درصورتی که توسط برنامه نویس هندل نشد مقدار یا رفتار default خود را انجام ندهد. که اینکار معادل با <code>()event.preventDefault</code>
در کد js است. می‌توان از سینتکس زیر استفاده کرد :

```html
<form @submit.prevent="onSubmit">...</form>
```

در حالت کلی یک دایرکتیو کامل به صورت مقابل است : 
<code>"Name:Argument.Modifier="Value</code>
<br>
<hr>
<h2>نکاتی دررابطه با Reactivity</h2>
همانطور که پیشتر دیدیم برای توصیف اولیه یک متغیر که قرار است در reactivity system قرار بگیرد و باهرتغییر از سمت vue این تغییر در DOM هم اعمال شود ما نیاز داشتیم (البته در دیزاین Option-Api)
که متغیرها و پراپرتی های مورد نظر را در بخش data تعریف کنیم. وسپس در بخش‌های دیگر کامپوننت مانند mounted با this (که به خود اینستنس اشاره می‌کند) قابل دسترسی اند.

```js
export default {
  data() {
    return {
      count: 1
    }
  },
  mounted() {
    // `this` refers to the component instance.
    console.log(this.count) // => 1

    // data can be mutated as well
    this.count = 2
  }
}
```

این پراپرتی ها تنها هنگامی اضافه می‌شوند که اینستنس مربوط به اپ ساخته می‌شود. بنابراین بعدا نمی‌توان یک پراپرتی با قابلیت reactive بودن با استفاده از this.X = a (به عنوان مثال ) ساخت. البته یک متغیر در کامپوننت خواهد شد ولی دیگر خاصیت ریکتیو بودن را ندارد.پس اگر از مقدار یک متغیر در ابتدا مطمئن نیستید می‌توانید در دیتا null یا undefined ریترن کنید.

```js
export default {
  data() {
    return {
      someObject: {}
    }
  },
  mounted() {
    const newObject = {}
    this.someObject = newObject

    console.log(newObject === this.someObject) // false
  }
}
```
نکته : درمثال بالا همانطور که گفتیم someObject خاصیت ریکتیو بودن خود را دارد اما newObject ریکتیو نخواهد بود!
<br>
<h3>متودها</h3>
همانطور که دیدیم می‌توانستیم با استفاده از this دسترسی به پراپرتی مورد نظر خود را در داخل یک تابع که درون اسکوپ :methodes قرار دارد داشته باشیم.توجه داشته باشید که از نوشتن تابع ها به صورت اشاره‌گر خودداری کنید چرا که دیگر دسترسی ای به this نخواهید داشت!

```js
export default {
  methods: {
    increment: () => {
      // BAD: no `this` access here!
    }
  }
}
```
<h3>ویو دارای ریکتیویتی عمیق یا Deep Reactivity است</h3>
منظور چیست؟ یعنی اگر یک ابجکت داشته باشیم که ابجکت ها و یا آرایه های تودرتو داشته باشیم و بخواهیم یکی از فرزندان داخلی را تغییر دهیم همچنان ویو متوجه می‌شود و با توجه به خاصیت ریکتیو بودن DOM را اپدیت می‌کند. به عنوان مثال :

```js
export default {
  data() {
    return {
      obj: {
        nested: { count: 0 },
        arr: ['foo', 'bar']
      }
    }
  },
  methods: {
    mutateDeeply() {
      // these will work as expected.
      this.obj.nested.count++
      this.obj.arr.push('baz')
    }
  }
}
```
<h3>صف آپدیت DOM</h3>
توجه کنید که تغییرات روی کامپوننت ها همه همزمان برروی DOM اعمال نمی‌شوند بلکه یک صفی وجود دارد که ویو آپدیت ها را در آن بافر می کند.برای اینکه آپدیت ها را نگه داریم تا پس از یک تغییر در یک پراپرتی اتفاق بیفتند می‌توان از سینتکس زیر استفاده کرد:

```js
import { nextTick } from 'vue'

export default {
  methods: {
    async increment() {
      this.count++
      await nextTick()
      // Now the DOM is updated
    }
  }
}
```
<hr>
<h2>Computed Properties</h2>
فرض کنید که ما یک سری آبجکت در اپشن دیتای خود داریم :<br>
<br>

```js
export default {
  data() {
    return {
      author: {
        name: 'John Doe',
        books: [
          'Vue 2 - Advanced Guide',
          'Vue 3 - Basic Guide',
          'Vue 4 - The Mystery'
        ]
      }
    }
  }
}
```
حال اگر بخواهیم به صورت شرطی یک سری دیتا را بایند کنیم چه کار میکنیم؟همانطور که پیشتر نیز دیدیم می‌توان کد js را به داخل دیتابایندینگ ها برد : 

```html
<p>Has published books:</p>
<span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>
```

اما همیشه این انتخاب خوبی نیست مخصوصا اگر عبارتی که داخل دیتابایندینگ می‌آید پیچیده شود. آنگاه کد خوانایی و ماندگاری خودش را تا حد خوبی از دست خواهد داد. پس چاره چیست؟
در اینجا computed propery ها به کمک ما می‌آیند : 

```js
export default {
  data() {
    return {
      author: {
        name: 'John Doe',
        books: [
          'Vue 2 - Advanced Guide',
          'Vue 3 - Basic Guide',
          'Vue 4 - The Mystery'
        ]
      }
    }
  },
  computed: {
    // a computed getter
    publishedBooksMessage() {
      // `this` points to the component instance
      return this.author.books.length > 0 ? 'Yes' : 'No'
    }
  }
}
```
ما آنها را در آپشن Computed() می‌گذاریم و داخل آنها مانند متودها یک نوع تابع تعریف می‌کنیم!اما توجه کنید که این تابع نیست و بعدتر توضیح می‌دهیم که فرقی با متود چیست.
سپس می‌توان به سادگی <code>publishedBooksMessage</code>
را بجای لاجیکی که بالاتر به‌کار بردیم درون دیتابایندینگ استفاده کرد :

```html
<p>Has published books:</p>
<span>{{ publishedBooksMessage }}</span>
```
و همچنان خاصیت ریکتیو بودن را حفظ می‌کند.
<br>
اما اگر دقت کنید می‌توانستیم به سادگی از یک متود درون آپشن methods استفاده کنیم. پس چرا نیازی به Computed داشتیم؟

```js
// in component
methods: {
  calculateBooksMessage() {
    return this.author.books.length > 0 ? 'Yes' : 'No'
  }
}
```
تفاوت اینها در ساختار آنهاست. پراپرتی های Computed همواره نگاه به مقادیر ریکتیوی که درون آنهاست و به آنها وابسته اند می‌کنند و به محض تغییر دوباره محاسبه و اپدیت می‌شوند بنابرین اگر DOM دوباره رندر شود ولی ولیو های مورد استفاده از یک Computed تغییری نداشته باشند دیگر دوباره محاسبه و اپدیت نمی‌شود. اما در متود ها اینگونه نیست!هربار که یک نوع re-render در صفحه ما اتفاق می‌افتد آنها دوباره گتر یک تابع را صدا زده و آنرا کال می‌کنند و خروجی را برمی‌گردانند هرچند که یکسان بوده باشد!اما در Computed ها نوعی کش داریم که درصورتی که تغییر نکرده باشند همان مقدار قبلی را سریعا و در کسری از ثانیه برمی‌گردانند. بنابراین Computed پراپرتی ها یک ابزار قدرتمند برای سرعت بخشیدن به وب اپ ما خواهد شد!
توجه کنید که نتیجه از لحاظ منطقی چه با استفاده از Computed و چه با استفاده از method یکسان است اما تفاوت در لود و زمانی است که این دو نتیجه می‌دهند.
<hr>

</div>
